## Databases

**Original artifact**

[Original C++ Farkle](https://github.com/groberge/groberge.github.io/tree/main/DS_Algorithm_Farkle){:target="_blank"}

**Enhanced artifact**

[Updated C++ Farkle](https://github.com/groberge/groberge.github.io/tree/main/Database_Farkle){:target="_blank"}

The artifact that was chosen for this milestone is an updated version of a game called Farkle that was originally written in C++ for the IT-312 course from 2017.  This version is a result of changes made during the Algorithm and Data Structures enhancement to improve the speed and efficiency of the game as well as resolve some bugs that were present in the original.  This program includes user-defined classes called Player and Gameplay along with some standard C++ libraries.  Within the Player class, there are attributes to hold the player’s name, score and whether they are the winning player along with the appropriate getter and setter functions.  The Gameplay class is initialized with a few private attributes, a constant variable for the winning score and many methods for the functionality of the game.
  
The main application instantiates the Gameplay class, an alias called PlayerVector representing a vector of the players and initializes the combination of the srand and time functions to ensure random values are achieved during the rolling of the dice.  It then shows the rules using a function from the Gameplay class that displays a file to the screen and runs another Gameplay function called numberPlayers which prompts the user for the number of players who will be playing.  

After requesting each player’s name from the users and adding it to the vector, the game begins by displaying the current player and initiating the takeTurn function for that player.  This function uses a reference to the current player and the PlayerVector and declares a vector of integers to be used to hold the values of the dice.  It then calls promptForRoll which performs a few checks according to the rules of Farkle to see if a roll of the dice should be enforced and prompts the user to roll or quit if no enforced roll is needed.  If the player chooses to quit, then the score for the roll is returned to the program.  If they choose to roll, then a function called diceRoll is used to loop through a specified number of dice and add the values to a vector to return to the program.  Once this is completed, the scoringDice function is used to process the score for the player’s turn and starts by using a function called displayDice which counts the number of each dice value, displays the number of each value and returns a map to the program. The map is then analyzed to see if there are any triplets or other scoring dice in the roll. As each set of scoring dice is found, the user is prompted whether to save those dice to score and the appropriate points are calculated. Any dice that are saved are removed from the number of dice for the next roll and this and the score are returned to the takeTurn function using a pair from the Standard Template Library to hold both values.  The play continues until the player has no scoring dice on a given roll or they choose to quit rolling.  

At the end of each turn, the player’s new score is set, all current scores are displayed and then a function is used to check if the current player’s score is over 10,000.  If so, the bit is set to mark them as the winning player.  Once this occurs, the game loops through the other players and allows them to take a final turn until this player is reached again.  At this point, the player with the highest score is calculated using the calculateWinner function and the winner is congratulated.

This artifact was chosen because it currently has no database included, which makes it a great opportunity to research the available options for adding a new one, including the design and build process, without any previous setup or constraints.  After this research, a server-less solution based on SQLite was selected along with its limited configuration needs and small disk space footprint.  To communicate between C++ and SQLite, the SQLite C/C++ API interface was used throughout the program to get the required results and a new class called HighScore was created to hold the necessary functions and attributes.  The database, which consists of a Players table along with fields for id, name, high score, wins and losses, is created on the first run of the program.  It is then used during each game to show each player their stats at the start of the game and update the stats once the game is completed.  This functionality has improved the playing experience for the users by providing a record of their highest scores over time and a win/loss record for comparison against other players. 

Working on this enhancement helped showcase skills in designing and evaluating computing solutions to solve given problems and managing the trade-offs involved by taking an application that had no existing database and being able to research the available options before creating an implementation that gives the desired functionality and improves the gameplay.  This enhancement also demonstrated an ability to use well-founded and innovative techniques, skills and tools in computing practices to implement a computer solution to deliver value to the user.  Once a database type was selected, the available API interface was researched and learned to realize the functionality that was envisioned.  With these improvements, the course objectives that were planned to be met with this enhancement were successful.

The process of adding the database to the game was interesting as the original plan was to use MongoDB due to recent experience with that database, although it was quickly realized that all options had not been considered and it may not be the best option for this project.  After investigating other database options, the SQLite option offered the most effective solution to address the planned artifact enhancements.  This brought with it the challenge of learning a new database library and how to use it with C++ to get the results that were intended.  Going through this process helped to discover how to investigate ways to perform different tasks using an API that was unfamiliar and apply these functions to an existing application.  The biggest challenge during this enhancement was in understanding the options and their nuances when applying the functions to the program to make sure that it’s not only working correctly but is also not creating any bugs or inefficient code along the way.
